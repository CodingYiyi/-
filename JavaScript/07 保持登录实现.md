# 登录那点事儿

灵魂一问：真的需要登陆吗？

**有时候并不需要强制登录的APP把登录作为启动页**。用户对你的APP一无所知，你就要求对方注册并登录，除非APP本身已经很有名气或者是用户有强需求，否则正常人应该会直接把它删掉。

比较温和的方式是将一些并不需要登录，但可以给用户带来帮助的东西，第一时间展现给他们，让他们产生兴趣，再在合适的时机引导他们注册（比如使用需要使用更高级的功能，或用户需要收藏某个喜欢的信息时）。

灵魂二问：登录到底做了什么？

用户第一次登陆的时候，输入用户名密码，加密后（一种简单的实现：用户名密码加salt后再MD5，salt前后端协商一致即可）作为参数调用登陆接口，后端返回一段随机字符串，这段字符串就是我们身份的象征，后续会频繁使用。

>HTTP是无状态的，两个接口先后到达服务端，服务器没法判断是否为同一个用户所为（总不能每个接口都带着用户名作为参数吧？）。所以有了常见的cookie、token的概念。说白了就是把用户的信息映射到一段加密后的字符串，跟随着请求（一般在request header的Cookie或者 Authorization字段）发送给后端。


## session+cookie方式

Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器第一次发送登录请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其（Session ID）通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。

具体实现：

### 1.1 登录

首先用户通过post请求提交账户密码到服务器，服务器判断正确后生成一个sessionid，并将sessionid与userid等账户信息一起存储到内存性数据库(Redis)中，并将sessionid设置到cookies中响应。

### 1.2 登录保持

下次浏览器其他请求就可以从cookies中得到sessionid，从而从数据库中得到用户相关信息，则视为登录成功具有响应权限。当然我们应该为sessionid设置有效期。

### 1.3 登出

登出，则从数据中删除相应sessionid即可，以上即为web端的登录，登录保持，登出 简单的解决方案。

>cookie的优点：
>
1. 保存用户的登陆状态，例如上例中的，用户进行登陆，成功登陆后，服务器生成特定的cookie返回给客户端，客户端下次访问该域名下的任何页面，将该cookie的信息发送给服务器，服务器经过检验，来判断用户是否登陆。
2. 记录用户的行为，例如，京东商场左下角有一个最近访问的产品记录信息，当当网上有你最近浏览过的书籍信息，都是根据用户访问页面，记录到cookie的信息来制作的。
3. 电商购物车的处理，因为在不同页面，点击添加到购物车，这个信息也是记到了cookie里面。结账的时候统一提交。
4. 定制页面。如果网站提供了换肤的功能，我们这个时候也是将他记录到cookie里面，以便下次访问还是保持原来的风格页面。

>cookie带来的问题也很明显：
>
1. cookie是自动放置在request header中的，所以对一些不需要用到cookie的请求（资源文件、img等）也会被带上，浪费带宽。
2. cookie是保存在客户端的，只要未过期就可以在下次访问页面时继续使用，容易造成CSRF攻击（攻击者无需知道cookie的具体内容）。
3. cookie有长度限制，一般是4KB，超过会被截断，造成数据丢失。
4. 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力，这也意味着限制了应用的扩展能力（解决方案有session拷贝，统一的的session服务器等）。

## JWT的token机制
>Json Web Token (JWT)， 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

### JWT token组成

```
eyJhbGciOiJIUzI1.eyJzdWIiOiIxMjM0NTY9.TJVA95OeFONFh7HgQ
```
头部（header).载荷（payload).签证（signature).

### header：jwt的头部承载两部分信息：

* typ:声明类型，这里是jwt

* alg:声明加密的算法 通常直接使用 HMAC SHA256

### playload：载荷就是存放有效信息的地方。


* 标准中注册的声明 (建议但不强制使用) ：

1. iss: jwt签发者
1. sub: jwt所面向的用户
1. aud: 接收jwt的一方
1. exp: jwt的过期时间，这个过期时间必须要大于签发时间
1. nbf: 定义在什么时间之前，该jwt都是不可用的.
1. iat: jwt的签发时间
1. jti: jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。

* 公共的声明 ：
公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.

* 私有的声明 ：
私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。

### signature：jwt的第三部分是一个签证信息，这个签证信息由三部分组成：

* header (base64后的)
* payload (base64后的)
* secret 

> token带来的问题：
> 
1. JWT默认不加密，但可以加密。生成原始令牌后，可以使用改令牌再次对其进行加密。
3. JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。
4. JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。
5. 为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。

### 如何使token机制更安全？
* 如果我们在调用接口时，还附带一个当前时间戳参数timestamp，同时，用deviceid和这个时间戳再生成一个参数sign，比如 md5(deviceid timestamp token)这样的形式。而服务端首先验证一下参数中的时间戳与当前服务器时间是否一致（误差保持在合理范围内即可，比如5分钟），然后根据用户保存在服务器中的deviceid来对参数中的时间戳进行相同的变形，验证是否匹配，那便自然“更更安全”了。
* tips:如果对整个调用请求中的参数进行排序，再以deviceid和timestamp加上排序后的参数来对整个调用生成1个sign，黑客即使截获sign，不同的时间点、参数请求所使用的sign也是不同的，难以伪造，自然会更安全。当然，写起来也更费事。
* tips:Token以旧换新的机制，一个过期的Token只能换取一个新的Token，这是关键。 如果Token被盗, 黑客要持续使用也需持续的换取新的Token, 服务器一旦发现,一个旧Token多次试图换取新Token，表示有异常， 这时强制用户再次登陆。

## cookie 和 Token 的区别
1. cookie：本质上是一类特殊的token（不含内容），这种token这是一个唯一的hash值， 要知道这个token是谁，要到一个中心服务器查询。在中心服务器，用户数据可能储存于文件或是数据库或是Redis等。
2. JWT Token：这种token就像一个身份证，包含**公开**的用户信息， 通过签名机制确保token无法伪造。好处是不用到中心服务器查询（只需要根据签名机制验证有效即可），对于分布式系统很有用， 比如用户登陆后，要看视频，要下载文件。而视频，文件资源都需验证用户身份，视频，文件资源在不同的服务器，甚至由不同的公司提供，这时可分布式验证的JWT就很有用。
这种可分布式验证的Token通常发行了就不能注销，只能等其自行过期失效（也有办法使其失效，[这里](https://www.imqianduan.com/server/506.html)有介绍）。


## 保持登录怎么做？

### 1. session+cookie：session有自动延期机制（需要后端实现）

### 2. 使用一个有效期很长的token（小声BB：😓这么暴力吗?）

### 3. Access Token（长期） + Refresh Token（短期）
Oauth 2.0 标准推荐采用Refresh Token和Access Token。
Refresh Token 有效期很长， Access Token 有效期很短。
用户登陆后，同时获得Refresh Token 和 Access Token，平时就用 Access Token， Access Token 过期后就用Refresh Token 获取新的Access Token。
[实现token自动续期](https://www.imqianduan.com/server/503.html)
[axios如何利用promise无痛刷新token-请求后拦截](https://juejin.im/post/5d5ccdd75188255625591357)
[axios如何利用promise无痛刷新token-请求前拦截](https://juejin.im/post/5dcac7686fb9a04a9e37b595)

链接①：[理解 JWT 的使用场景和优劣](https://www.imqianduan.com/server/506.html)

链接②：[网易高手：角色权限设计的100种解法](https://www.imqianduan.com/server/511.html)