// https://www.runoob.com/w3cnote/shell-sort.html

/**
希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。
希尔排序是基于插入排序的以下两点性质而提出改进方法的：
插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。
1. 算法步骤
选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；
按增量序列个数 k，对序列进行 k 趟排序；
每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
 */

function shellSort (arr) {
    var len = arr.length,
        temp,
        gap = 1;
    while (gap < len / 3) { // 计算增量：gap = length/3 + 1，自己可以查阅为什么是除以3(除以3交换的次数最少，时间用的最少)
        gap = gap * 3 + 1; // 保证最后一次的增量为1
    }
    for (gap; gap > 0; gap = Math.floor(gap / 3)) { // 与计算增量规则相对应，最后一次增量为1（退化为插入排序）
        for (var i = gap; i < len; i++) { // 从当前间隔值位置开始遍历数组
            temp = arr[i];
            for (var j = i - gap; j >= 0 && arr[j] > temp; j -= gap) { // 注意此处由于计算增量系数为3，所以可能存在对比两次的情况：例如i=81的时候，j-=40为41，对比完后，j-=40，变为1，继续对比
                arr[j + gap] = arr[j];
            }
            arr[j + gap] = temp;
        }
    }
    return arr;
}

// 随机生成100个整数
// let testArr = []
// for (var i = 0; i < 100; i++) {
//     testArr.push(parseInt(Math.random() * 100))
// }
// console.log(testArr)

var testArr = [
    15, 68, 77, 41, 23, 42,  2, 74, 28, 12, 53, 88,
    32, 14, 35, 55, 60, 93, 12, 68, 49,  4, 19, 11,
    65, 39, 33, 37, 25, 57, 57, 12,  0, 25, 40, 34,
    85, 63, 63, 15,  7, 63, 34, 91, 98, 98, 95, 11,
    81,  8, 78, 93, 24,  9, 22, 81, 27,  7, 54, 84,
    37,  8, 70, 34, 55, 51, 39, 31, 10, 99, 43, 42,
    63,  3, 78, 51, 26, 97, 42, 74, 62, 17, 71, 86,
    55, 38, 88,  1, 96,  4, 66, 46, 44, 82, 77, 87,
    33, 81, 26, 80
  ]
console.log(shellSort(testArr))